{
  "name": "wagner-core",
  "version": "0.1.0",
  "description": "Dependency-injection-inspired async framework that doubles as an isomorphic AngularJS-compatible dependency injector.",
  "main": "index.js",
  "scripts": {
    "test": "mocha ./test/*.test.js",
    "coverage": "istanbul cover ./node_modules/mocha/bin/_mocha -- -R spec ./test/*"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/vkarpov15/wagner-core.git"
  },
  "dependencies": {
    "get-parameter-names": "0.2.0",
    "underscore": "1.5.2"
  },
  "devDependencies": {
    "acquit": "0.0.3",
    "istanbul": "0.3.2",
    "jscs": "1.9.0",
    "mocha": "2.0.1"
  },
  "jscsConfig": {
    "preset": "airbnb",
    "requireMultipleVarDecl": null,
    "disallowMultipleVarDecl": true
  },
  "author": {
    "name": "Valeri Karpov"
  },
  "license": "Apache 2.0",
  "readme": "# wagner-core\n\nDependency injector and DI-based async framework for writing modular, durable\nserver code.\n\n[![Build Status](https://travis-ci.org/vkarpov15/wagner-core.svg?branch=master)](https://travis-ci.org/vkarpov15/wagner-core)\n\nWagner is primarily designed to be a more elegant take on\n[orchestrator](https://www.npmjs.org/package/orchestrator), hence the name.\nIf you've used orchestrator for web apps and found it cumbersome, Wagner is\nfor you.\n\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/f/f3/Richard_Wagner_2.jpg\" width=\"140\" style=\"width: 140px\">\n\n# API\n\n## As a dependency injector\n\nWagner includes a basic dependency injector that provides an API similar to\n[AngularJS 1.x's dependency injector](https://docs.angularjs.org/guide/di).\n\n\n#### It allows you to execute async tasks based on parameter names\n\nYou register 'services' with Wagner using the `factory()` function.\nServices have a unique name - any function you pass through `factory()`\nor `invoke()` can list services in its parameter list.\n\n```javascript\n    \n    wagner.factory('bacon', function() {\n      return 'bacon';\n    });\n\n    wagner.factory('breakfast', function(bacon) {\n      return bacon + ' and eggs';\n    });\n\n    var result = wagner.invoke(function(breakfast) {\n      assert.equal(breakfast, 'bacon and eggs');\n      return breakfast;\n    });\n\n    assert.equal(result, 'bacon and eggs');\n  \n```\n\n#### It allows you to use locals\n\nA *local* is a value specific to a particular execution of\n`invoke()`. You can use locals like any other service.\n\n```javascript\n    \n    wagner.factory('eggs', function(number) {\n      return 'finished making ' + number + ' eggs';\n    });\n\n    wagner.invoke(function(eggs) {\n      assert.equal(eggs, 'finished making 4 eggs');\n    }, { number: 4 });\n  \n```\n\n#### It only executes the factory function once\n\nService functions are only executed once, the value is cached for\nall future calls to `invoke()`.\n\n```javascript\n    \n    var count = 0;\n    wagner.factory('eggs', function() {\n      ++count;\n      return 5;\n    });\n\n    assert.equal(count, 0);\n\n    wagner.invoke(function(eggs) {\n      assert.equal(eggs, 5);\n      assert.equal(count, 1);\n    });\n\n    wagner.invoke(function(eggs) {\n      assert.equal(count, 1);\n    });\n\n    assert.equal(count, 1);\n  \n```\n\n## As a way to reduce error-handling boilerplate\n\nIf you're a NodeJS developer, you've probably gotten sick of writing the\nfollowing code:\n\n```javascript\nfunction(error, res) { if (error) { return handleError(error); } }\n```\n\nThe `wagner.safe()` function helps you make that cleaner.\n\n#### It wraps callbacks to bubble up errors\n\n`wagner.safe()` returns an event emitter that has a `try()` function.\nJust wrap your callbacks in a `try()` and all async errors get deferred\nto your event emitter. Like domains, but with less suck.\n\n\n```javascript\n    \n    var safe = wagner.safe();\n\n    var asyncOpThatErrors = function(callback) {\n      setTimeout(function() {\n        callback('This is an error!');\n      });\n    };\n\n    asyncOpThatErrors(safe.try(function(error) {\n      // Never gets called: safe catches the error\n      assert.ok(false);\n    }));\n\n    safe.on('error', function(error) {\n      assert.equal(error, 'This is an error!');\n      done();\n    });\n  \n```\n\n#### It catches exceptions too\n\nThe `try()` function also wraps your callbacks in a try/catch and emits.\nany exceptions. Never again will a\n`TypeError: Cannot read property 'value' of undefined`\nin your callback crash your server.\n\n\n```javascript\n    \n    var safe = wagner.safe();\n\n    var asyncOpThatSucceeds = function(callback) {\n      setTimeout(function() {\n        callback();\n      });\n    };\n\n    asyncOpThatSucceeds(safe.try(function() {\n      throw 'Oops I messed up';\n    }));\n\n    safe.on('error', function(error) {\n      assert.equal(error.toString(), 'Oops I messed up');\n      done();\n    });\n  \n```\n\n## As an async framework\n\nWagner also includes the ability to execute async tasks in a\ndependency-injection-like way. Wagner has 2 functions, `invokeAsync()`\nand `task()`, that enable you to write neat modular async code.\n\n#### It can execute async tasks using `invokeAsync()`\n\nThe `task()` and `invokeAsync()` are roughly analogous to `factory`\nand `invoke()`. There are 3 differences:\n\n1. The function you pass to `task()` takes a callback, which it uses to\npass a value to dependent tasks.\n1. The function you pass to `invokeAsync()` takes an error, which\ncontains the first error that happened when executing the specified tasks.\n1. Tasks are re-executed every time you call `invokeAsync()`, whereas\nservices are cached forever.\n\n```javascript\n    \n    wagner.task('task1', function(callback) {\n      setTimeout(function() {\n        callback(null, 'test');\n      }, 50);\n    });\n\n    wagner.invokeAsync(function(error, task1) {\n      assert.ok(!error);\n      assert.equal(task1, 'test');\n      done();\n    });\n  \n```\n\n#### It re-executes tasks on subsequent calls to `invokeAsync()`\n\n```javascript\n    \n    var called = 0;\n    wagner.task('task1', function(callback) {\n      ++called;\n      setTimeout(function() {\n        callback(null, 'test');\n      }, 0);\n    });\n\n    wagner.invokeAsync(function(error, task1) {\n      assert.ok(!error);\n      assert.equal(task1, 'test');\n      assert.equal(called, 1);\n\n      wagner.invokeAsync(function(error, task1) {\n        assert.ok(!error);\n        assert.equal(task1, 'test');\n        assert.equal(called, 2);\n        done();\n      });\n    });\n  \n```\n\n#### It executes tasks with maximum parallelization\n\nTasks are executed at most once per call to `invokeAsync()`, and tasks\nare executed with maximum parallelization. That is, as soon as all a\ntasks dependencies are ready, the task executes.\n\n```javascript\n    \n    var executed = {};\n    wagner.task('readFile1', function(callback) {\n      assert.equal(Object.keys(executed).length, 0);\n      executed.readFile1 = true;\n      callback(null, 'test');\n    });\n\n    wagner.task('processFile1', function(readFile1, callback) {\n      assert.equal(Object.keys(executed).length, 1);\n      assert.ok(executed.readFile1);\n      setTimeout(function() {\n        callback(null, 'test');\n      }, 5);\n    });\n\n    wagner.task('logFile1', function(readFile1, callback) {\n      assert.equal(Object.keys(executed).length, 1);\n      assert.ok(executed.readFile1);\n      setTimeout(function() {\n        callback(null, 'test');\n      }, 5);\n    });\n\n    wagner.invokeAsync(function(error, processFile1, logFile1) {\n      assert.ifError(error);\n      done();\n    });\n  \n```\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/vkarpov15/wagner-core/issues"
  },
  "_id": "wagner-core@0.1.0",
  "_from": "wagner-core@0.1.0"
}
